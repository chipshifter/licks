// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Empty {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Certificate {
    #[prost(enumeration = "SignatureScheme", tag = "1")]
    pub scheme: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub self_signature_of_inner: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CertificateChain {
    #[prost(message, optional, tag = "3")]
    pub account_certificate: ::core::option::Option<Certificate>,
    #[prost(bytes = "vec", tag = "4")]
    pub account_to_device_signature: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub device_certificate: ::core::option::Option<Certificate>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticationChallengePayload {
    #[prost(message, optional, tag = "1")]
    pub chain: ::core::option::Option<CertificateChain>,
    #[prost(bytes = "vec", tag = "2")]
    pub client_bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub signature_of_hash: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ed25519CertificateChainSecret {
    #[prost(message, optional, tag = "1")]
    pub public: ::core::option::Option<CertificateChain>,
    #[prost(bytes = "vec", tag = "2")]
    pub account_secret: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub device_secret: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignatureScheme {
    Ed25519 = 0,
}
impl SignatureScheme {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SignatureScheme::Ed25519 => "ED25519",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ED25519" => Some(Self::Ed25519),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceId {
    #[prost(bytes = "vec", tag = "1")]
    pub uuid: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountId {
    #[prost(bytes = "vec", tag = "1")]
    pub uuid: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupId {
    #[prost(bytes = "vec", tag = "1")]
    pub uuid: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegistrationService {
    #[prost(oneof = "registration_service::Stage", tags = "1, 2, 3")]
    pub stage: ::core::option::Option<registration_service::Stage>,
}
/// Nested message and enum types in `RegistrationService`.
pub mod registration_service {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Stage {
        #[prost(message, tag = "1")]
        StageOne(super::Stage1),
        #[prost(message, tag = "2")]
        StageTwo(super::Stage2),
        #[prost(message, tag = "3")]
        StageThree(super::Stage3),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stage1 {
    #[prost(oneof = "stage1::Inner", tags = "1, 2")]
    pub inner: ::core::option::Option<stage1::Inner>,
}
/// Nested message and enum types in `Stage1`.
pub mod stage1 {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Inner {
        #[prost(bytes, tag = "1")]
        HereIsMyAccountPublicKey(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "2")]
        HereIsYourAccountId(super::AccountId),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stage2 {
    #[prost(message, optional, tag = "1")]
    pub here_is_my_account_certificate: ::core::option::Option<Certificate>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stage3 {
    #[prost(message, optional, tag = "1")]
    pub here_is_my_certificate_chain: ::core::option::Option<CertificateChain>,
    #[prost(bytes = "vec", tag = "2")]
    pub username: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LicksSignaturePayload {
    #[prost(enumeration = "LicksSignatureScheme", tag = "1")]
    pub scheme: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceSignature {
    #[prost(message, optional, tag = "1")]
    pub signer: ::core::option::Option<DeviceId>,
    #[prost(message, optional, tag = "2")]
    pub payload: ::core::option::Option<LicksSignaturePayload>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountSignature {
    #[prost(message, optional, tag = "1")]
    pub signer: ::core::option::Option<AccountId>,
    #[prost(message, optional, tag = "2")]
    pub payload: ::core::option::Option<LicksSignaturePayload>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LicksSignatureScheme {
    UninitializedLicksSignatureScheme = 0,
    HybridEd25519Falcon512 = 1,
    OpenmlsEcdsaSecp256r1Sha256 = 2,
    OpenmlsEcdsaSecp384r1Sha384 = 3,
    OpenmlsEcdsaSecp521r1Sha512 = 4,
    OpenmlsEd25519 = 5,
    OpenmlsEd448 = 6,
}
impl LicksSignatureScheme {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LicksSignatureScheme::UninitializedLicksSignatureScheme => {
                "UNINITIALIZED_LICKS_SIGNATURE_SCHEME"
            }
            LicksSignatureScheme::HybridEd25519Falcon512 => {
                "LICKS_SIGNATURE_SCHEME_HYBRID_ED25519_FALCON512"
            }
            LicksSignatureScheme::OpenmlsEcdsaSecp256r1Sha256 => {
                "OPENMLS_ECDSA_SECP256R1_SHA256"
            }
            LicksSignatureScheme::OpenmlsEcdsaSecp384r1Sha384 => {
                "OPENMLS_ECDSA_SECP384R1_SHA384"
            }
            LicksSignatureScheme::OpenmlsEcdsaSecp521r1Sha512 => {
                "OPENMLS_ECDSA_SECP521R1_SHA512"
            }
            LicksSignatureScheme::OpenmlsEd25519 => "OPENMLS_ED25519",
            LicksSignatureScheme::OpenmlsEd448 => "OPENMLS_ED448",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNINITIALIZED_LICKS_SIGNATURE_SCHEME" => {
                Some(Self::UninitializedLicksSignatureScheme)
            }
            "LICKS_SIGNATURE_SCHEME_HYBRID_ED25519_FALCON512" => {
                Some(Self::HybridEd25519Falcon512)
            }
            "OPENMLS_ECDSA_SECP256R1_SHA256" => Some(Self::OpenmlsEcdsaSecp256r1Sha256),
            "OPENMLS_ECDSA_SECP384R1_SHA384" => Some(Self::OpenmlsEcdsaSecp384r1Sha384),
            "OPENMLS_ECDSA_SECP521R1_SHA512" => Some(Self::OpenmlsEcdsaSecp521r1Sha512),
            "OPENMLS_ED25519" => Some(Self::OpenmlsEd25519),
            "OPENMLS_ED448" => Some(Self::OpenmlsEd448),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatServiceMessage {
    #[prost(oneof = "chat_service_message::Inner", tags = "2, 3, 4, 5, 6, 7, 8, 9")]
    pub inner: ::core::option::Option<chat_service_message::Inner>,
}
/// Nested message and enum types in `ChatServiceMessage`.
pub mod chat_service_message {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BlindedAddressSecret {
        #[prost(bytes = "vec", tag = "1")]
        pub secret: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", tag = "2")]
        pub public: ::prost::alloc::vec::Vec<u8>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GetMessageRequest {
        #[prost(message, optional, tag = "1")]
        pub blinded_address: ::core::option::Option<BlindedAddressSecret>,
        #[prost(bytes = "vec", tag = "2")]
        pub delivery_id: ::prost::alloc::vec::Vec<u8>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MlsMessage {
        #[prost(bytes = "vec", tag = "1")]
        pub delivery_id: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", tag = "2")]
        pub body: ::prost::alloc::vec::Vec<u8>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SendMessageRequest {
        #[prost(message, optional, tag = "1")]
        pub blinded_address: ::core::option::Option<BlindedAddressSecret>,
        #[prost(bytes = "vec", tag = "2")]
        pub mls_message_out: ::prost::alloc::vec::Vec<u8>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StartListeningRequest {
        #[prost(bytes = "vec", tag = "1")]
        pub listener_id: ::prost::alloc::vec::Vec<u8>,
        #[prost(message, optional, tag = "2")]
        pub blinded_address: ::core::option::Option<BlindedAddressSecret>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StopListening {
        #[prost(bytes = "vec", tag = "1")]
        pub listener_id: ::prost::alloc::vec::Vec<u8>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Inner {
        #[prost(message, tag = "2")]
        RetreiveQueue(GetMessageRequest),
        #[prost(message, tag = "3")]
        SubscribeToAddress(StartListeningRequest),
        #[prost(message, tag = "4")]
        StopListening(StopListening),
        #[prost(message, tag = "5")]
        MlsMessage(MlsMessage),
        #[prost(uint64, tag = "6")]
        QueueDone(u64),
        #[prost(message, tag = "7")]
        QueueEmpty(super::Empty),
        #[prost(message, tag = "8")]
        SendMessage(SendMessageRequest),
        #[prost(bytes, tag = "9")]
        Delivered(::prost::alloc::vec::Vec<u8>),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyPackages {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub inner: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticatedChannelMessage {
    #[prost(oneof = "authenticated_channel_message::Inner", tags = "1, 2, 3, 4, 5, 6")]
    pub inner: ::core::option::Option<authenticated_channel_message::Inner>,
}
/// Nested message and enum types in `AuthenticatedChannelMessage`.
pub mod authenticated_channel_message {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Inner {
        #[prost(bytes, tag = "1")]
        SetUsername(::prost::alloc::vec::Vec<u8>),
        #[prost(bytes, tag = "2")]
        RemoveUsername(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "3")]
        UsernameIsAlreadyYours(super::Empty),
        #[prost(message, tag = "4")]
        UsernameIsAlreadyTaken(super::Empty),
        #[prost(message, tag = "5")]
        UploadKeyPackages(super::KeyPackages),
        #[prost(message, tag = "6")]
        KeyPackageAlreadyUploaded(super::Empty),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnauthenticatedChannelMessage {
    #[prost(
        oneof = "unauthenticated_channel_message::Inner",
        tags = "1, 2, 3, 4, 5, 6, 7, 8"
    )]
    pub inner: ::core::option::Option<unauthenticated_channel_message::Inner>,
}
/// Nested message and enum types in `UnauthenticatedChannelMessage`.
pub mod unauthenticated_channel_message {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Inner {
        #[prost(message, tag = "1")]
        Registration(super::RegistrationService),
        #[prost(message, tag = "2")]
        GetKeyPackage(super::AccountId),
        #[prost(bytes, tag = "3")]
        HereIsKeyPackage(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "4")]
        NoKeyPackage(super::Empty),
        #[prost(bytes, tag = "5")]
        GetAccountFromUsername(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "6")]
        HereIsAccount(super::AccountId),
        #[prost(message, tag = "7")]
        ChatService(super::ChatServiceMessage),
        #[prost(message, tag = "8")]
        NoAccount(super::Empty),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LicksMessageWire {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub request_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(
        oneof = "licks_message_wire::LicksMessageBody",
        tags = "2, 4, 5, 6, 7, 8, 9, 10"
    )]
    pub licks_message_body: ::core::option::Option<licks_message_wire::LicksMessageBody>,
}
/// Nested message and enum types in `LicksMessageWire`.
pub mod licks_message_wire {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum LicksMessageBody {
        #[prost(enumeration = "super::LicksApiError", tag = "2")]
        Error(i32),
        #[prost(message, tag = "4")]
        Authenticated(super::AuthenticatedChannelMessage),
        #[prost(message, tag = "5")]
        Unauthenticated(super::UnauthenticatedChannelMessage),
        #[prost(bytes, tag = "6")]
        Challenge(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "7")]
        ChallengeResponse(super::AuthenticationChallengePayload),
        #[prost(bytes, tag = "8")]
        Ping(::prost::alloc::vec::Vec<u8>),
        #[prost(bytes, tag = "9")]
        Pong(::prost::alloc::vec::Vec<u8>),
        #[prost(enumeration = "super::EmptyMessageBody", tag = "10")]
        Empty(i32),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LicksApiError {
    UninitializedLicksError = 0,
    InvalidCredentials = 1,
    InvalidOperation = 2,
    DecodeError = 3,
    InternalError = 4,
    ConnectionIsClosed = 5,
    UnknownError = 6,
    InvalidRequest = 7,
}
impl LicksApiError {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LicksApiError::UninitializedLicksError => "UNINITIALIZED_LICKS_ERROR",
            LicksApiError::InvalidCredentials => "INVALID_CREDENTIALS",
            LicksApiError::InvalidOperation => "INVALID_OPERATION",
            LicksApiError::DecodeError => "DECODE_ERROR",
            LicksApiError::InternalError => "INTERNAL_ERROR",
            LicksApiError::ConnectionIsClosed => "CONNECTION_IS_CLOSED",
            LicksApiError::UnknownError => "UNKNOWN_ERROR",
            LicksApiError::InvalidRequest => "INVALID_REQUEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNINITIALIZED_LICKS_ERROR" => Some(Self::UninitializedLicksError),
            "INVALID_CREDENTIALS" => Some(Self::InvalidCredentials),
            "INVALID_OPERATION" => Some(Self::InvalidOperation),
            "DECODE_ERROR" => Some(Self::DecodeError),
            "INTERNAL_ERROR" => Some(Self::InternalError),
            "CONNECTION_IS_CLOSED" => Some(Self::ConnectionIsClosed),
            "UNKNOWN_ERROR" => Some(Self::UnknownError),
            "INVALID_REQUEST" => Some(Self::InvalidRequest),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EmptyMessageBody {
    Ignore = 0,
    GetChallenge = 1,
    Ok = 2,
    Bye = 3,
}
impl EmptyMessageBody {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EmptyMessageBody::Ignore => "IGNORE",
            EmptyMessageBody::GetChallenge => "GET_CHALLENGE",
            EmptyMessageBody::Ok => "OK",
            EmptyMessageBody::Bye => "BYE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IGNORE" => Some(Self::Ignore),
            "GET_CHALLENGE" => Some(Self::GetChallenge),
            "OK" => Some(Self::Ok),
            "BYE" => Some(Self::Bye),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Content {
    #[prost(oneof = "content::Inner", tags = "1")]
    pub inner: ::core::option::Option<content::Inner>,
}
/// Nested message and enum types in `Content`.
pub mod content {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Inner {
        #[prost(string, tag = "1")]
        BasicText(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationMessage {
    #[prost(bytes = "vec", tag = "1")]
    pub client_timestamp: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub sender_server: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub sender_account_id: ::core::option::Option<AccountId>,
    #[prost(uint32, tag = "4")]
    pub version: u32,
    #[prost(message, optional, tag = "5")]
    pub content: ::core::option::Option<Content>,
}
