//! Implementation of "certificates" for binding keys to identities. Used for MLS credentials.
//! There are three types of certificates we actually care about:
//! - A server certificate, generated by the server. It signs account certificates. It is the "root"
//!   certificate and is self-signed. It is checked by relevant authentication services to check that
//!   a user
//! - Account certificates, generated by users (one per user). It signs device credentials.
//! - Device certificates, generated by devices (one per device, 1-to-n devices per user). It is used
//!   as the MLS credential within groups etc.
use core::fmt::Debug;
use ed25519::{Ed25519AccountCert, Ed25519CertificateChain, Ed25519DeviceCert};
use prost::Message;
use serde::{Deserialize, Serialize};

use crate::{
    api::{proto, server::Server},
    error::ProtoError,
    identifiers::{AccountId, DeviceId},
};

pub mod ed25519;

#[derive(Debug, thiserror::Error, PartialEq)]
pub enum CertificateError {
    #[error("Could not deserialize inner data of the certificates.")]
    InvalidData,
    #[error("The public key or signature could not be deserialized from bytes.")]
    CryptoDeserialization,
    #[error("The certificate (or one of its contents) could not be deserialized from bytes.")]
    ProtoDeserialization(#[from] ProtoError),
    #[error("This signature is invalid.")]
    InvalidSignature,
}

/// A [`Certificate`] contains:
///
/// - Some data ([`AccountId`]+[`Server`] in the case of
///   [`Ed25519AccountCert`], and [`DeviceId`] for [`Ed25519DeviceCert`])
/// - A public key defining that certificate
/// - A signature of the certificate (including the public key),
///   signed by the public key itself.
pub trait Certificate {
    fn to_proto(&self) -> proto::Certificate;
    /// Convert to bytes using the protobuf representation
    fn to_bytes(&self) -> Vec<u8> {
        self.to_proto().encode_to_vec()
    }
    fn pub_key_bytes(&self) -> Vec<u8>;
    fn get_scheme(&self) -> SignatureScheme;
    fn verify_self_signature(&self) -> Result<(), CertificateError>;
}

/// Traits to handle certificate chains.
///
/// A certificate chain is made of the following
/// - A self-signed account certificate
/// - A self-signed device certificate
/// - A signature of the device certificate,
///   made by the account certificate
pub trait CertificateChain {
    fn serialize(self) -> SerializedChain;
    fn to_bytes(self) -> Vec<u8>
    where
        Self: Sized,
    {
        let serialized = self.serialize();
        let proto: proto::CertificateChain = serialized.into();

        proto.encode_to_vec()
    }
    fn get_server(&self) -> &Server;
    fn account_id(&self) -> &AccountId;
    fn device_id(&self) -> &DeviceId;
    fn account_cert(&self) -> &impl Certificate;
    fn device_cert(&self) -> &impl Certificate;
    fn verify_self(&self) -> Result<(), CertificateError>;
    fn verify_signature(&self, message: &[u8], signature: &[u8]) -> Result<(), CertificateError>;
}

pub trait CertificateChainSecret {
    fn serialized(&self) -> SerializedChain;
    fn sign(&self, message: &[u8]) -> Vec<u8>;
}

/// A serialized account certificate. Should really only be used for registration, since
/// we deal with full chains outside of it (using [`SerializedChain`]).
///
/// This serialized certificate is untrusted. In order to use it, we must verify its contents
/// by calling [`Self::verify`].
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SerializedAccountCertificate {
    Ed25519(Box<Ed25519AccountCert>),
}

impl SerializedAccountCertificate {
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, CertificateError> {
        let proto = proto::Certificate::decode(bytes).map_err(|_| CertificateError::InvalidData)?;

        proto.try_into()
    }

    pub fn verify(self) -> Result<(impl Certificate, AccountId), CertificateError> {
        match self {
            SerializedAccountCertificate::Ed25519(ed25519_account_cert) => {
                if ed25519_account_cert.verify_self_signature().is_ok() {
                    let account_id = ed25519_account_cert.account_id;
                    Ok((*ed25519_account_cert, account_id))
                } else {
                    Err(CertificateError::InvalidSignature)
                }
            }
        }
    }
}

impl TryFrom<proto::Certificate> for SerializedAccountCertificate {
    type Error = CertificateError;

    fn try_from(value: proto::Certificate) -> Result<Self, Self::Error> {
        // Data is [account_id][server].
        let mut account_id = value.data;
        let server = account_id.split_off(size_of::<AccountId>());

        let ed25519_cert = Ed25519AccountCert {
            server: Server::from_vec(server).map_err(|_| CertificateError::InvalidData)?,
            account_id: AccountId::try_from(account_id.as_slice())
                .map_err(|_| CertificateError::InvalidData)?,
            pub_key: ed25519::Ed25519PublicKey::try_from(value.public_key.as_slice())
                .map_err(|_| CertificateError::InvalidData)?,
            self_signature: ed25519::Ed25519Signature::from_slice(&value.self_signature_of_inner)
                .map_err(|_| CertificateError::InvalidData)?,
        };

        Ok(Self::Ed25519(Box::new(ed25519_cert)))
    }
}

impl From<SerializedAccountCertificate> for proto::Certificate {
    fn from(value: SerializedAccountCertificate) -> Self {
        match value {
            SerializedAccountCertificate::Ed25519(ed25519_account_cert) => {
                ed25519_account_cert.to_proto()
            }
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
/// A serialized chain is a representation [`Ed25519CertificateChain`] meant
/// to be stored in MLS credentials or sent to the server. In this state, it
/// should not be trusted, and [`Self::verify`] must be called before performing
/// operations on it
pub enum SerializedChain {
    Ed25519Chain(Ed25519CertificateChain),
}

impl SerializedChain {
    pub fn pub_key_bytes(&self) -> Vec<u8> {
        match self {
            SerializedChain::Ed25519Chain(ed25519_certificate_chain) => ed25519_certificate_chain
                .device_cert
                .pub_key
                .to_bytes()
                .to_vec(),
        }
    }

    pub fn account_id(&self) -> &AccountId {
        match self {
            SerializedChain::Ed25519Chain(ed25519_certificate_chain) => {
                &ed25519_certificate_chain.account_cert.account_id
            }
        }
    }

    pub fn to_bytes(self) -> Vec<u8> {
        proto::CertificateChain::from(self).encode_to_vec()
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<Self, CertificateError> {
        proto::CertificateChain::decode(bytes)
            .map_err(|_| CertificateError::InvalidData)?
            .try_into()
    }

    pub fn verify(self) -> Result<impl CertificateChain, CertificateError> {
        match self {
            SerializedChain::Ed25519Chain(ed25519_certificate_chain) => {
                if ed25519_certificate_chain.verify_self().is_ok() {
                    Ok(ed25519_certificate_chain)
                } else {
                    Err(CertificateError::InvalidSignature)
                }
            }
        }
    }
}

impl TryFrom<proto::CertificateChain> for SerializedChain {
    type Error = CertificateError;

    fn try_from(value: proto::CertificateChain) -> Result<Self, Self::Error> {
        let account_cert_proto = value
            .account_certificate
            .ok_or(CertificateError::InvalidData)?;

        let device_cert_proto = value
            .device_certificate
            .ok_or(CertificateError::InvalidData)?;

        let account_cert = match account_cert_proto.scheme() {
            proto::SignatureScheme::Ed25519 => {
                let mut account_id = account_cert_proto.data;
                let server = account_id.split_off(size_of::<AccountId>());
                Ed25519AccountCert {
                    server: Server::from_vec(server).map_err(|_| CertificateError::InvalidData)?,
                    account_id: AccountId::try_from(account_id.as_slice())
                        .map_err(|_| CertificateError::InvalidData)?,
                    pub_key: ed25519::Ed25519PublicKey::try_from(
                        account_cert_proto.public_key.as_slice(),
                    )
                    .map_err(|_| CertificateError::InvalidData)?,
                    self_signature: ed25519::Ed25519Signature::from_slice(
                        &account_cert_proto.self_signature_of_inner,
                    )
                    .map_err(|_| CertificateError::InvalidData)?,
                }
            }
        };

        let device_cert = match device_cert_proto.scheme() {
            proto::SignatureScheme::Ed25519 => Ed25519DeviceCert {
                device_id: DeviceId::try_from(device_cert_proto.data.as_slice())
                    .map_err(|_| CertificateError::InvalidData)?,
                pub_key: ed25519::Ed25519PublicKey::try_from(
                    device_cert_proto.public_key.as_slice(),
                )
                .map_err(|_| CertificateError::InvalidData)?,
                self_signature: ed25519::Ed25519Signature::from_slice(
                    &device_cert_proto.self_signature_of_inner,
                )
                .map_err(|_| CertificateError::InvalidData)?,
            },
        };

        Ok(Self::Ed25519Chain(Ed25519CertificateChain {
            account_cert: Box::new(account_cert),
            account_to_device_sig: Box::new(
                ed25519::Ed25519Signature::from_slice(&value.account_to_device_signature)
                    .map_err(|_| CertificateError::InvalidData)?,
            ),
            device_cert: Box::new(device_cert),
        }))
    }
}

impl From<SerializedChain> for proto::CertificateChain {
    fn from(value: SerializedChain) -> Self {
        match value {
            SerializedChain::Ed25519Chain(ed25519_certificate_chain) => Self {
                account_certificate: Some(ed25519_certificate_chain.account_cert.to_proto()),
                account_to_device_signature: ed25519_certificate_chain
                    .account_to_device_sig
                    .to_vec(),
                device_certificate: Some(ed25519_certificate_chain.device_cert.to_proto()),
            },
        }
    }
}

/// All the signature scheme implementations we support for certificates.
/// Prost has an enum for it, and implements to/from i32. For serialization
/// purposes we'll use i32.
pub enum SignatureScheme {
    Ed25519,
}

#[cfg(test)]
pub mod tests {
    use ed25519::{Ed25519AccountCert, Ed25519CertificateChainSecret, Ed25519DeviceCert};

    use crate::identifiers::{DeviceId, LicksIdentifier};

    use super::*;

    pub fn generate_fake_chain_secret() -> impl CertificateChainSecret {
        let (account_cert, account_secret) =
            Ed25519AccountCert::generate(Server::localhost(), AccountId::generate_id());

        let (device_cert, device_secret) = Ed25519DeviceCert::generate(DeviceId::generate_id());

        Ed25519CertificateChainSecret::new(account_cert, account_secret, device_cert, device_secret)
    }
}
