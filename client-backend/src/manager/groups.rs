//! (TODO)
//!
//! The group is an abstraction layer between mls-rs's `Group`
//! and their associated `GroupIdentifier`. All groups are identified
//! by their `GroupIdentifier` and called by the group manager.
//!
//! It should be by design that anything outside of [`GroupManager`] does not handle
//! directly with the mls-rs `Group` struct.
//!
//! The group manager also contains helper functions for user interfaces.
use std::sync::Arc;

use crate::{
    client::ClientProfile,
    messages::MlsApplicationMessage,
    mls::credentials::{LicksIdentityProvider, LicksMlsCredential},
    ui::GroupUi,
};

use super::{error::Result, MlsClient, MlsClientConfig, ProfileManager, WEBSOCKET_MANAGER};
use anyhow::{bail, Context};
use mls_rs::{
    error::MlsError, group::proposal::Proposal, mls_rs_codec::MlsDecode, ExtensionList, Group,
    MlsMessage,
};

use lib::{
    api::{
        group::SendMessageRequest,
        messages::{ChatServiceMessage, Message, UnauthRequest},
        proto::{self, ApplicationMessage, ProstMessage},
    },
    crypto::blinded_address::{BlindedAddressPublic, BlindedAddressSecret},
    identifiers::{AccountId, GroupIdentifier, LicksIdentifier},
};

type MlsGroup = Group<MlsClientConfig>;

/// `GroupManager` is a level of abstraction between the front-end
/// and the database that keeps track of `GroupIdentifier` <-> `MlsGroup`.
pub struct GroupManager {
    mls_client: Arc<MlsClient>,
}

pub enum ProcessedMessage {
    /// This returns when the received message can be ignored,
    /// for instance when receiving a message we wrote ourselves.
    Ignore,
    /// Indicate that the epoch of the group was updated. When
    /// that happens, this means that the epoch secret changes,
    /// and so the blinded address also changed. We include the
    /// new one and its epoch.
    Commit(u64, BlindedAddressPublic, Vec<ProcessedCommit>),
    ApplicationMessage(MlsApplicationMessage),
}

pub enum ProcessedCommit {
    Unknown,
    AddedMember(AccountId),
}

impl GroupManager {
    pub fn init(mls_client: Arc<MlsClient>) -> Result<Self> {
        Ok(GroupManager { mls_client })
    }

    /// Creates a new group and saves it to the database. If `group_config` is set to None
    /// then the default configuration (as specified in `constants.rs`)
    /// will be used.
    fn create_group(
        &self,
        extension_list: ExtensionList,
        group_identifier: Option<GroupIdentifier>,
    ) -> Result<GroupIdentifier> {
        let group_identifier = group_identifier.unwrap_or_else(GroupIdentifier::generate_id);

        let mut group = self
            .mls_client
            .create_group_with_id(group_identifier.to_bytes().to_vec(), extension_list)?;

        group.write_to_storage()?;

        // TODO: Save group info into SQLite database

        Ok(group_identifier)
    }

    /// This doesn't verify that the [`GroupIdentifier`] is valid/generated by the server. See Issue #6
    pub fn join_group_from_welcome(
        &self,
        welcome: &mls_rs::MlsMessage,
    ) -> Result<(GroupIdentifier, MlsGroup)> {
        let (mut group, _new_member_info) = self.mls_client.join_group(None, welcome)?;

        group.write_to_storage()?;

        let group_identifier: GroupIdentifier = group.group_id().try_into()?;

        // TODO: Save group info into SQLite database

        Ok((group_identifier, group))
    }

    /// Updates the blinded address of a group to that has updated their group secret (like after a commit)
    /// in the database and updates connection listeners.
    /// Returns `Ok(true)` if the blinded address changed and is not in the database.
    /// `Ok(false)` if the groups calculated blinded address is already registered to a group.
    // NOTE may cause issues if there are hash collisions between 2 different groups
    /// ---
    /// You should update a group's listener if this returns `Ok(true)`
    pub fn get_blinded_address_and_epoch(
        &self,
        group_id: &GroupIdentifier,
    ) -> Result<(BlindedAddressSecret, u64)> {
        let group = self.load_mls_rs_group(group_id)?;
        let blinded_address = Self::generate_blinded_address(&group)?;
        let epoch = group.current_epoch();
        Ok((blinded_address, epoch))
        // The database also needs to know the epoch, so we may have to pass that down this function?
    }

    /// Internal function to load and handle the group as a [`mls_rs::Group`] type directly.
    /// This should not be used outside of [`GroupManager`]. Instead, use the other functions
    #[inline]
    fn load_mls_rs_group(&self, group_identifier: &GroupIdentifier) -> Result<MlsGroup> {
        Ok(self
            .mls_client
            .load_group(group_identifier.as_uuid().as_bytes())?)
    }

    /// The `bool` returns `true` if the group
    #[allow(clippy::too_many_lines)]
    pub fn process_incoming_message(
        &self,
        group_identifier: &GroupIdentifier,
        message: &[u8],
    ) -> Result<ProcessedMessage> {
        // Load our MLS group using the blinded address we got
        match self.load_mls_rs_group(group_identifier) {
            Ok(mut group) => {
                let Ok(mls_message) = mls_rs::MlsMessage::from_bytes(message) else {
                    bail!("Failed to deserialize mls message from bytes");
                };
                // Decrypt the message
                let processed_message_result = group.process_incoming_message(mls_message);

                let processed_message = match processed_message_result {
                    Ok(message) => message,
                    Err(error) => match error {
                        MlsError::CantProcessMessageFromSelf | MlsError::InvalidEpoch => {
                            // We automatically ignore invalid epoch because at that
                            // point the epoch is too old
                            return Ok(ProcessedMessage::Ignore);
                        }
                        _ => {
                            bail!("Failed to process incoming message: {:?}", error);
                        }
                    },
                };

                group.write_to_storage()?;

                log::info!("Processed mls message {:?}", &processed_message);

                match processed_message {
                    mls_rs::group::ReceivedMessage::ApplicationMessage(application_message) => {
                        let Ok(protobuf) = ApplicationMessage::decode(application_message.data())
                        else {
                            bail!("Failed to deserialize application message protobuf from bytes");
                        };

                        let Ok(message) = MlsApplicationMessage::try_from(protobuf.clone()) else {
                            bail!(
                                "Failed to deserialize application message from protobuf {:?}",
                                protobuf
                            );
                        };

                        // the sender_id should match the sender index of the application message
                        let author_index_member = group
                            .member_at_index(application_message.sender_index)
                            .context("Message sent from a member not in the group.")?;

                        let Some(credential) = LicksIdentityProvider::resolve_to_licks_credential(
                            &author_index_member.signing_identity,
                        ) else {
                            bail!(
                                "Member does not have a licks credential. index: {}",
                                application_message.sender_index
                            );
                        };

                        if message.sender_account_id.eq(credential.chain.account_id()) {
                            Ok(ProcessedMessage::ApplicationMessage(message))
                        } else {
                            bail!("Application message sender does not match the application message body, discarding message...");
                        }
                    }
                    mls_rs::group::ReceivedMessage::Commit(commit) => {
                        let processed_commits: Vec<ProcessedCommit> = match commit.effect {
                            mls_rs::group::CommitEffect::NewEpoch(new_epoch) => {
                                new_epoch
                                    .applied_proposals
                                    .into_iter()
                                    .map(|prop| {
                                        match prop.proposal {
                                            Proposal::Add(add_proposal) => {
                                                // A new member has been added into the group
                                                // We add that new contact to the database if we don't know it already
                                                if let Some(cred) =
                                                LicksIdentityProvider::resolve_to_licks_credential(
                                                    add_proposal.signing_identity(),
                                                )
                                            {
                                                ProcessedCommit::AddedMember(
                                                    *cred.chain.account_id(),
                                                )
                                            } else {
                                                ProcessedCommit::Unknown
                                            }
                                            }
                                            _ => ProcessedCommit::Unknown,
                                        }
                                    })
                                    .collect()
                            }
                            _ => vec![],
                        };
                        // Because this is a commit, the epoch has now changed.
                        // We then calculate the new blinded address, update the db tree,
                        // and return the new blinded address

                        Ok(ProcessedMessage::Commit(
                            group.current_epoch(),
                            // TODO: Save blinded address secret somewhere and reuse it.
                            Self::generate_blinded_address(&group)?.to_public(),
                            processed_commits,
                        ))
                    }
                    mls_rs::group::ReceivedMessage::Proposal(proposal) => {
                        log::trace!("Proposal received ({proposal:?})");
                        todo!();
                    }
                    mls_rs::group::ReceivedMessage::GroupInfo(group_info) => {
                        log::trace!("Group info received ({group_info:?})");
                        todo!();
                    }
                    // Do nothing on receiving welcome and keypackage
                    mls_rs::group::ReceivedMessage::Welcome => {
                        log::trace!("Welcome message received");
                        todo!();
                    }
                    mls_rs::group::ReceivedMessage::KeyPackage(key_package) => {
                        log::trace!("Key package received ({:?})", key_package);
                        todo!()
                    }
                }
            }
            Err(err) => {
                bail!("Failed to load group: {:?}", err);
            }
        }
    }

    /// Internal function that passes [`Group`] directly so we don't load it
    /// everytime. The public function that takes a [`GroupIdentifier`] instead
    /// is at [`Self::get_blinded_address`].
    #[inline]
    fn generate_blinded_address(
        mls_group: &Group<MlsClientConfig>,
    ) -> Result<BlindedAddressSecret> {
        let secret = mls_group.epoch_authenticator()?;
        Ok(BlindedAddressSecret::from_group_secret(secret.as_bytes()))
    }

    pub fn get_blinded_address(
        &self,
        group_identifier: &GroupIdentifier,
    ) -> Result<BlindedAddressSecret> {
        let group = self.load_mls_rs_group(group_identifier)?;
        Self::generate_blinded_address(&group)
    }
}

impl ClientProfile<'_> {
    pub async fn create_new_group(
        &self,
        group_name: String,
        group_description: Option<String>,
    ) -> Result<GroupUi> {
        let group_ui = self.create_group_without_listener(group_name, group_description)?;

        self.client
            .listener_manager
            .listen(
                self.profile_manager.clone(),
                group_ui.group_identifier,
                self.client.notification_manager.clone(),
            )
            .await?;

        Ok(group_ui)
    }

    pub async fn create_self_group(&self) -> Result<GroupUi> {
        // TODO: Add checks to make sure we didn't already create it?

        let group_ui = self.create_self_group_without_listener()?;

        self.client
            .listener_manager
            .listen(
                self.profile_manager.clone(),
                group_ui.group_identifier,
                self.client.notification_manager.clone(),
            )
            .await?;

        Ok(group_ui)
    }

    pub async fn create_new_welcome(
        &self,
        group_id: GroupIdentifier,
        account_id: AccountId,
    ) -> Result<MlsMessage> {
        let (welcome_message, new_epoch, new_blinded_address) = self
            .create_welcome_for_user_without_updating_listener(&group_id, account_id)
            .await?;

        self.client
            .listener_manager
            .listen_new_epoch(
                self.profile_manager.clone(),
                group_id,
                new_epoch,
                new_blinded_address.to_public(),
            )
            .await?;

        Ok(welcome_message)
    }

    pub async fn join_group_from_welcome_and_listen(
        &self,
        welcome: &MlsMessage,
    ) -> Result<GroupIdentifier> {
        let (group_identifier, mls_group) = self.group_manager.join_group_from_welcome(welcome)?;

        let blinded_address = GroupManager::generate_blinded_address(&mls_group)?;
        let epoch = mls_group.current_epoch();

        // TODO: Issue #78
        let group_name = "Untitled Group".to_string();
        let group_description = None;

        self.profile_manager.sqlite_database.add_group_info(
            group_identifier,
            group_name,
            group_description,
            epoch,
            blinded_address,
        )?;

        for member in mls_group.roster().members_iter() {
            let member_cred = member.signing_identity;
            let licks_mls_cred: LicksMlsCredential = member_cred.try_into()?;

            self.profile_manager.sqlite_database.add_new_contact(
                *licks_mls_cred.chain.account_id(),
                None,
                None,
                None,
            )?;
        }

        self.client
            .listener_manager
            .listen(
                self.profile_manager.clone(),
                group_identifier,
                self.client.notification_manager.clone(),
            )
            .await?;
        Ok(group_identifier)
    }
}

impl ProfileManager {
    /// Returns the group id of all groups stored inside the MLS client.
    pub fn get_all_group_ids(&self) -> Result<Vec<GroupIdentifier>> {
        Ok(self
            .mls_client
            .group_state_storage()
            .group_ids()?
            .iter()
            .filter_map(|vec| GroupIdentifier::try_from(vec.as_slice()).ok())
            .collect())
    }

    /// Creates a new group. This function does the following:
    ///
    /// 1) Requests a `GroupId` generated by the server. The server is
    ///    the one associated to the profile.
    ///
    /// 2) Uses the [`GroupIdentifier`] it got to create the group.
    ///
    /// 3) Stores the state of this new group into the database. Returns
    ///    relevant information for the client to display.
    ///
    /// If the HTTP requests fail, then this function will fail.
    /// If `group_config` is set to None then the default group configuration
    /// (as specified in `constants.rs`) will be used.
    pub fn create_group_without_listener(
        &self,
        group_name: String,
        group_description: Option<String>,
    ) -> Result<GroupUi> {
        let group_name = Arc::new(group_name);
        let extensions = ExtensionList::default();

        let group_identifier = self.group_manager.create_group(extensions, None)?;

        let (blinded_address, epoch) = self
            .group_manager
            .get_blinded_address_and_epoch(&group_identifier)?;

        self.sqlite_database.add_group_info(
            group_identifier,
            group_name.as_str(),
            group_description,
            epoch,
            blinded_address,
        )?;

        Ok(GroupUi {
            group_identifier,
            group_name,
            last_message: None,
        })
    }

    pub fn create_self_group_without_listener(&self) -> Result<GroupUi> {
        let group_name = Arc::new("Personal Notes".to_string());
        let group_description = Some(
            "Your very own little group to store all kinds of notes between all your devices."
                .to_string(),
        );

        let extensions = ExtensionList::default();

        let group_identifier = self
            .group_manager
            .create_group(extensions, Some(GroupIdentifier::self_id()))?;

        let (blinded_address, epoch) = self
            .group_manager
            .get_blinded_address_and_epoch(&group_identifier)?;

        self.sqlite_database.add_group_info(
            group_identifier,
            group_name.as_str(),
            group_description,
            epoch,
            blinded_address,
        )?;

        Ok(GroupUi {
            group_identifier,
            group_name,
            last_message: None,
        })
    }

    pub async fn create_welcome_for_user_without_updating_listener(
        &self,
        group_id: &GroupIdentifier,
        account_id: AccountId,
    ) -> Result<(MlsMessage, u64, BlindedAddressSecret)> {
        // TODO: When we get a ContactManager, we move that logic there
        // Let the database know about this user
        self.sqlite_database
            .add_new_contact(account_id, None, None, None)?;

        let mut group = self
            .group_manager
            .load_mls_rs_group(group_id)
            .context("Group couldn't be found in database")?;

        let key_package = match WEBSOCKET_MANAGER
            .request_unauth(
                self.profile.get_server(),
                UnauthRequest::GetKeyPackage(account_id),
            )
            .await?
        {
            Message::Unauth(UnauthRequest::HereIsKeyPackage(key_package)) => {
                let mut key_package = key_package.as_slice();
                let key_package = MlsMessage::mls_decode(&mut key_package)
                    .context("Failed to decode keypackage")?;

                if key_package.wire_format() == mls_rs::WireFormat::KeyPackage {
                    key_package
                } else {
                    bail!("Keypackage data does not encode a keypackage");
                }
            }
            Message::Unauth(UnauthRequest::NoKeyPackage) => {
                bail!("Account has not keypackages");
            }
            other => {
                bail!("Received unexpected response from the server: {other:?}");
            }
        };
        let add_commit = group.commit_builder().add_member(key_package)?.build()?;

        WEBSOCKET_MANAGER
            .request_unauth(
                self.profile.get_server(),
                UnauthRequest::ChatService(ChatServiceMessage::SendMessage(SendMessageRequest {
                    blinded_address_proof: GroupManager::generate_blinded_address(&group)?
                        .create_proof(add_commit.commit_message.to_bytes()?),
                })),
            )
            .await?;

        group.apply_pending_commit()?;
        group.write_to_storage()?;

        let new_blinded_address = GroupManager::generate_blinded_address(&group)?;

        Ok((
            add_commit
                .welcome_messages
                .into_iter()
                .nth(0)
                .expect("there should be at least one welcome message"),
            group.current_epoch(),
            new_blinded_address,
        ))
    }

    pub async fn send_application_message(
        &self,
        group_id: &GroupIdentifier,
        content: crate::messages::Content,
    ) -> Result<()> {
        // TODO: Add a mechanism where we store "pending" messages that haven't sent yet (or if ever).

        let message = MlsApplicationMessage::build(content.clone(), &self.profile);

        let mut group = self
            .group_manager
            .load_mls_rs_group(group_id)
            .context("Group couldn't be found in database")?;

        let application_message = {
            let bytes = proto::ApplicationMessage::from(message).encode_to_vec();
            let mls_message = &mut group.encrypt_application_message(&bytes, Vec::default())?;

            mls_message.to_bytes()?
        };

        let blinded_address_proof =
            GroupManager::generate_blinded_address(&group)?.create_proof(application_message);

        let resp = WEBSOCKET_MANAGER
            .request_unauth(
                self.profile.get_server(),
                UnauthRequest::ChatService(ChatServiceMessage::SendMessage(SendMessageRequest {
                    blinded_address_proof,
                })),
            )
            .await?;

        match resp {
            Message::Unauth(UnauthRequest::ChatService(ChatServiceMessage::Delivered(
                delivery_stamp,
            ))) => {
                self.sqlite_database.add_message(
                    content,
                    self.profile.get_account_id(),
                    &delivery_stamp,
                    group_id,
                )?;
            }
            other => {
                log::error!("Message did not deliver, received: {other:?}");
                bail!("Message did not deliver: received: {other:?}");
            }
        }

        group.write_to_storage()?;

        Ok(())
    }
}
